<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Locks - Operating Systems: Book Summary</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> The Process</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Process API</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Mechanism - Limited Direct Execution</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Scheduling</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Multi-Level Feedback Queue</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> Proportional Share</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> Address Spaces</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> Mechanism - Address Translation</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">9.</strong> Segmentation</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> Free-Space Management</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> Paging - Introduction</a></li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> Paging - Faster Translation</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">13.</strong> Paging - Smaller Tables</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> Beyond Physical Memory - Mechanism</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">15.</strong> Physical Memory - Policies</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">16.</strong> Concurrency - An Introduction</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">17.</strong> Thread API</a></li><li class="chapter-item expanded "><a href="chapter_19.html" class="active"><strong aria-hidden="true">18.</strong> Locks</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">19.</strong> Lock-Based Concurrent Data Structures</a></li><li class="chapter-item expanded "><a href="chapter_21.html"><strong aria-hidden="true">20.</strong> Condition Variables</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Operating Systems: Book Summary</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="19-locks"><a class="header" href="#19-locks">19. Locks</a></h1>
<p>We want to execute a series of instruction atomically, due to the presence of interrupts, we couldn't. To solve this we introduce lock, which we put around critical section and ensure this sections is executed as a single atomic instruction. </p>
<h2 id="the-basic-idea"><a class="header" href="#the-basic-idea">The basic idea</a></h2>
<p>We have a critical section that looks like this:</p>
<pre><code class="language-C">balance = balance + 1;
</code></pre>
<p>To use a lock, we add some code around the critical section like this:</p>
<pre><code class="language-C">lock_t mutex; // Some globally-allocated lock `mutex`
...
lock(&amp;mutex);
balance = balance + 1;
unlock(&amp;mutex);
</code></pre>
<ul>
<li>Lock is just a variable </li>
<li>It stores the state of the lock at any given time</li>
<li>It's either available or acquired</li>
<li>We can store more data in the lock such as the current thread that's holding it, or a list of some kind for ordering lock acquisition</li>
</ul>
<p>The general flow of locks are describe here: </p>
<ul>
<li>Calling <code>lock()</code> tries to acquire the lock</li>
<li>If no other thread holds the lock, the thread will acquire the lock and enter the critical section</li>
<li>If another thread tries to acquire the lock, the thread will not return while the lock is held by another thread. This way, other threads are prevented from entering the critical section. .</li>
<li>Once the owner of the lock calls <code>unlock()</code>, the lock is now available again to other threads. </li>
<li>If there are no other threads waiting for the lock, the state of the lock is set to free. </li>
<li>If there are waiting threads, one of them will notice and will acquire the lock and enter critical section.</li>
</ul>
<p>With locks we make sure than only a single thread can access a critical section of code. </p>
<h2 id="pthread-locks"><a class="header" href="#pthread-locks">Pthread locks</a></h2>
<p>The name the POSIX library uses for a lock is <code>mutex</code> as it is used to provide mutual exclusion between threads. When you see the following threads code, assume that's doing the same thing as above: </p>
<pre><code class="language-C">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

Pthread_mutex_lock(&amp;lock); // wrapper; exits on failure
balance = balance + 1;
Pthread_mutex_unlock(&amp;lock);
</code></pre>
<p>Passing a variable to lock and unlock helps us avoid locking all threads with one lock (coarse-grained locking strategy) and doing a more specific thread lock (a more fine-grained approach) </p>
<h2 id="evaluating-locks"><a class="header" href="#evaluating-locks">Evaluating Locks</a></h2>
<p>To build locks we must defined some evaluation criteria:</p>
<ul>
<li>Does the lock provides mutual exclusion. Does the lock work, preventing multiple threads from accessing a critical section.</li>
<li>Fairness. Does each thread contending the lock gets a fair shot at acquiring it once its free. </li>
<li>Performance. The time overheads added by using the lock. 
<ul>
<li>When a single thread grabs and releases the lock, what's the overhead of doing so</li>
<li>Is there a performance overhead when multiple threads are contending for a lock. </li>
<li>How does the lock performs when there are multiple CPU's involved and threads on each contending lock. </li>
</ul>
</li>
</ul>
<h2 id="controlling-interrupts"><a class="header" href="#controlling-interrupts">Controlling interrupts</a></h2>
<p>One solution to implement mutex was to disable interrupts for critical sections. The could would look like this: </p>
<pre><code class="language-C">void lock() {
	DisableInterrupts();
} 
void unlock() {
	EnableInterrupts();
}
</code></pre>
<p>Assuming that we are running on a single processor system, by turning off interrupts before entering a critical section, we ensure that the code inside this section won't be interrupted </p>
<h4 id="benefits"><a class="header" href="#benefits">Benefits</a></h4>
<ul>
<li>Simplicity: Easy to implement and to grasp. </li>
</ul>
<h4 id="negatives"><a class="header" href="#negatives">Negatives</a></h4>
<ul>
<li>This allows any calling thread to perform a privileged operation, we must trust that this is not abused. </li>
<li>Greedy program calls lock and never <code>unlock</code> hence taking over the entire CPU</li>
<li>Buggy or malicious program could call <code>lock</code> and enter a loop, OS never regains control and we must restart the entire system</li>
<li>Does not work on multiple CPUs systems, if a thread disables interrupts, a thread running on a different CPU can still access critical section. </li>
<li>Running off interrupts for extended period of time can lead to interrupts becoming lost. </li>
<li>Inefficient: Code that mask and unmask interrupts are CPU inefficient. </li>
</ul>
<p>This negatives <strong>might</strong> be acceptable when running OS level programs, since the OS trust it self. </p>
<h2 id="just-using-loadsstores"><a class="header" href="#just-using-loadsstores">Just Using Loads/Stores</a></h2>
<p>Block using single flag variable (<code>flag</code>) to indicate whether some thread has possession of a lock. </p>
<ul>
<li>The first thread that enters the critical section calls <code>lock()</code> which check if the <code>flag</code> is set to 1 (in this case, is not), and then sets the flag to 1 to indicate that the thread now holds the lock. </li>
<li>When the thread finishes with the critical section, it calls <code>unlock()</code> which clears the flag</li>
<li>If another thread calls <code>lock()</code> while the lock is held, it will find that the flag is set to 1 so it will simply <em>spin-wait</em> in a while loop for that thread to call <code>unlock</code> and clear the flag</li>
<li>Once that first thread does clear the flag, the waiting thread fall out of the while loop, sets the flag to 1 for itself and proceeds into the critical section .</li>
</ul>
<pre><code class="language-C">typedef struct __lock_t { int flag; } lock_t;

void init(lock_t *mutex) {
	// 0 -&gt; lock is available, 1 -&gt; held
	mutex-&gt;flag = 0;
}
void lock(lock_t *mutex) {
	while (mutex-&gt;flag == 1) // TEST the flag
		;
	mutex-&gt;flag = 1; // now SET it!
}
void unlock(lock_t *mutex) {
	mutex-&gt;flag = 0;
}
</code></pre>
<p>This implementation has two errors.</p>
<ol>
<li>The first one is that we can easily produce a case where both threads set the flag to 1, and both threads are thus able to enter critical section. </li>
<li>The second being a performance error, the <code>lock</code> routine does a <strong>spin-waiting</strong>, which wastes time waiting for another thread to release a lock but at the same time running on the CPU. On a single CPU system, how can a thread be waiting for a lock while using the CPU if the other threads needs to use it to free the lock? Doesn't makes sense. </li>
</ol>
<h2 id="building-working-spin-locks-with-test-and-set"><a class="header" href="#building-working-spin-locks-with-test-and-set">Building working spin locks with test and set</a></h2>
<p>System designers started to invent hardware support for locking. The test-and-set instruction is one implementation of this hardware support. 
In this example we see test-and-set in practice via C code: </p>
<pre><code class="language-C">int TestAndSet(int *old_ptr, int new) {
	int old = *old_ptr; // Fetch old value at old ptr;
	*old_ptr = new; // Store 'new' into old_ptr
	return old; // return the old value
}

typedef struct __lock_t {
	int flag;
} lock_t;

void init(lock_t *lock) {
	// 0: lock is available, 1: lock is held
	lock-&gt;flag = 0;
}

void lock(lock_t *lock) {
	while (TestAndSet(&amp;lock-&gt;flag, 1) == 1)
		; // spin-wait (do nothing)
}

void unlock(lock_t *lock) {
	lock-&gt;flag = 0;
}
</code></pre>
<p>First case, a thread calls <code>lock</code>:</p>
<ul>
<li>No other threads currently holds the lock (thus <code>flag</code> is 0).</li>
<li>Thread calls <code>TestAndSet(flag, 1)</code>, which returns the old value (0)</li>
<li>The thread breaks the loop since the returned value is 0</li>
<li>The thread also atomically set the value of <code>flag</code> to 1 thus indicating that the thread is now held </li>
<li>We the threads finishes execution of the critical section, <code>unlock</code> is called. 
The second case is:</li>
<li>Other thread already has the lock held (<code>flag</code> is 1)</li>
<li>Another thread calls <code>TestAndSet(flag, 1)</code></li>
<li><code>TestAndSet</code> returns the old values which is 1, while simultaneously setting it to 1 again </li>
<li>As long as other threads holds the lock, 1 will be returned and thus this thread will spin and spin until the lock is finally released. </li>
</ul>
<p>This <code>TestAndSet</code> is actually an atomtic instruction implemented on the hardware level, hence it can't be interrupted. Hence we ensure that only one thread acquire the lock. </p>
<h2 id="evaluating-spin-locks"><a class="header" href="#evaluating-spin-locks">Evaluating Spin Locks</a></h2>
<p>Given the previous spin lock we can evaluate it. </p>
<ul>
<li>Correctness: Does it provide mutual exclusion? Yes, it only allows a single thread to enter critical section at a time. </li>
<li>Fairness. Spin locks doesn't provide any fairness guarantees. A thread might spin forever, under contention and wont execute the critical section. </li>
<li>Performance: We analyze this on a single process and a multi processor system:
<ul>
<li>Single processor: Performance is bad. If a thread holding the lock is preempted within the critical section, the scheduler might run every other thread, each of them runs for a slice of time. A waste of CPU cycles. </li>
<li>On multiple CPU's. Performance is reasonably well. Thread A hold a lock in CPU 1, thread B spin in CPU2, spinning  to wait the lock on another processor doesn't waste many cycles in this case. </li>
</ul>
</li>
</ul>
<h2 id="compare-and-swap"><a class="header" href="#compare-and-swap">Compare-And-Swap</a></h2>
<p>Hardware primitive that some systems provide. The C pseudocode looks like this: </p>
<pre><code class="language-C">int CompareAndSwap(int *ptr, int expected, int new) {
	int original = *ptr;
	if (original == expected)
		*ptr = new;
	return original;
}
</code></pre>
<p>And the lock instruction: </p>
<pre><code class="language-C">void lock(lock_t *lock) {
	while (CompareAndSwap(&amp;lock-&gt;flag, 0, 1) == 1)
		; // spin
}
</code></pre>
<p>This tests if the value that <code>ptr</code> is pointing to, is the <code>expected</code>. If so, update the value that <code>ptr</code> is pointing to, to <code>new</code>. Finally return the <code>original</code> value. </p>
<h2 id="load-linked-and-store-conditional"><a class="header" href="#load-linked-and-store-conditional">Load-Linked and Store-Conditional</a></h2>
<p>Hardware instruction, the C pseudocode looks like this: </p>
<pre><code class="language-C">int LoadLinked(int *ptr) {
	return *ptr;
}
int StoreConditional(int *ptr, int value) {
	if (no update to *ptr since LoadLinked to this address) {
		*ptr = value;
		return 1; // success!
	} else {
		return 0;
	}
}

void lock(lock_t *lock) {
	while (1) {
		while (LoadLinked(&amp;lock-&gt;flag) == 1)
			; // Spin until it's zero
		if (StoreConditional(&amp;lock-&gt;flag, 1) == 1)
			return; // If set-it-to-1 was a success: all done
					// Otherwise: try all over again
	}
}

void unlock(lock_t *lock) {
	lock-&gt;flag = 0;
}
</code></pre>
<ul>
<li>Store-conditional: It only succeeds if no intervening store to the address has taken place. </li>
<li><code>lock()</code>: A thread spins waiting for the flag to be set to 0</li>
<li>Once so, thread tries to acquire the lock via the store-conditional</li>
</ul>
<h2 id="fetch-and-add"><a class="header" href="#fetch-and-add">Fetch-and-Add</a></h2>
<p>Hardware primitive, atomically increments a value while returning the old value at a particular address. C pseudocode: </p>
<pre><code class="language-c">int FetchAndAdd(int *ptr) {
	int old = *ptr;
	*ptr = old + 1;
	return old;
}
typedef struct __lock_t {
	int ticket;
	int turn;
} lock_t;

void lock_init(lock_t *lock) {
	lock-&gt;ticket = 0;
	lock-&gt;turn = 0;
}

void lock(lock_t *lock) {
	int myturn = FetchAndAdd(&amp;lock-&gt;ticket);
	while (lock-&gt;turn != myturn)
		; // spin 
}

void unlock(lock_t *lock) {
	lock-&gt;turn = lock-&gt;turn + 1;
}
</code></pre>
<ul>
<li>Ticket and turn value. </li>
<li>When a thread wishes to acquire a lock it does an atomic fetch-and-add on the ticket value, the value is considered the thread's turn (<code>myturn</code>). </li>
<li>The globally shared <code>lock-&gt;turn</code> is used to determine which thread's turn it is.</li>
<li>When <code>myturn == turn</code> then the thread can run</li>
<li>Unlock is done by adding 1 to the <code>lock-&gt;turn</code> value.</li>
</ul>
<h2 id="spin-performance"><a class="header" href="#spin-performance">Spin performance</a></h2>
<p>We have 2 threads: </p>
<ul>
<li>Thread 0 is in critical section and thus has a lock held, then it get interrumpted. </li>
<li>Thread 1 tries to acquire the lock, but finds it held, it start looping and wasting cpu time. </li>
<li>Hardware support can't fix this problem, OS support is needed. </li>
</ul>
<h2 id="spin-solution-yield"><a class="header" href="#spin-solution-yield">Spin solution: Yield</a></h2>
<p>When you are going to spin, instead just give up the CPU to another thread. This can be represented in C code: </p>
<pre><code class="language-C">void init() {
	flag = 0;
}
void lock() {
	while (TestAndSet(&amp;flag, 1) == 1)
		yield(); // give up the cpu 
}
void unlock() {
	flag = 0;
}
</code></pre>
<p>Yield is a system call that moves the caller from the running state to the ready state. Thus promoting promotes another thread to running.</p>
<ul>
<li>Good enough we have few threads</li>
<li>Bad when we start having a lot of threads, and we have to yield a lot of times, hence still wasting CPU time (still better that the no yield approach)</li>
<li>The cost of context switch is present in this solution. </li>
<li>Starvation it's still present in this solution</li>
</ul>
<h2 id="using-queues"><a class="header" href="#using-queues">Using Queues</a></h2>
<p>A thread has either to spin waiting for the lock or yield the CPU, either way there's waste and no prevention of starvation. 
This can be improved with OS support in terms of two calls: </p>
<ul>
<li><code>park()</code> to put calling thread to sleep</li>
<li><code>unpark(threadID)</code> to wake a particular thread as designated by <code>threadID</code></li>
<li>This can be used to put the caller to sleep with it tries to acquire a held lock and wakes it when the lock is free 
C code representation of this: </li>
</ul>
<pre><code class="language-C">typedef struct __lock_t {
  int flag; // If flag is set to 0 we can run the thread, else we add it to tue queue and park it
  int guard; // This is to control access of flag and queue
  queue_t *queue;
} lock_t;

void lock_init(lock_t *m) {
  m-&gt;flag = 0;
  m-&gt;guard = 0;
  queue_init(m-&gt;queue);
}

void lock(lock_t *m) {
  while (TestAndSet(&amp;m-&gt;guard, 1) == 1) // We try to acquire read and write access to flag and queue
    ;  // acquire guard lock
  if (m-&gt;flag == 0) { // If flag = 0, we can run (held lock)
    m-&gt;flag = 1;
    m-&gt;guard = 0;
  } else { // else we add it to tue queue, park and continue
			// hold held by other thread
    queue_agdd(m-&gt;queue, gettid());
	setpark(); 
    m-&gt;guard = 0;
    park();
  }
}

void unlock(lock_t *m) {
  while (TestAndSet(&amp;m-&gt;guard, 1) == 1)
    ;  // acquire guard lock
  if (queue_empty(m-&gt;queue)) {
    m-&gt;flag = 0;
  } else {
    unpark(queue_remove(m-&gt;queue));
  }
  m-&gt;guard = 0;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_18.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="chapter_20.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_18.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="chapter_20.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
