<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Physical Memory - Policies - Operating Systems: Book Summary</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> The Process</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Process API</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Mechanism - Limited Direct Execution</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Scheduling</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Multi-Level Feedback Queue</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> Proportional Share</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> Address Spaces</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> Mechanism - Address Translation</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">9.</strong> Segmentation</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> Free-Space Management</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> Paging - Introduction</a></li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> Paging - Faster Translation</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">13.</strong> Paging - Smaller Tables</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> Beyond Physical Memory - Mechanism</a></li><li class="chapter-item expanded "><a href="chapter_15.html" class="active"><strong aria-hidden="true">15.</strong> Physical Memory - Policies</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">16.</strong> Concurrency - An Introduction</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">17.</strong> Thread API</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">18.</strong> Locks</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">19.</strong> Lock-Based Concurrent Data Structures</a></li><li class="chapter-item expanded "><a href="chapter_21.html"><strong aria-hidden="true">20.</strong> Condition Variables</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Operating Systems: Book Summary</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="15-physical-memory---policies"><a class="header" href="#15-physical-memory---policies">15. Physical Memory - Policies</a></h1>
<p>When there's no much memory free, the operating system is forced to start paging out pages to make room for actively-used pages. Deciding which page to evict and which page not to is described in the replacement policy. </p>
<h2 id="cache-management"><a class="header" href="#cache-management">Cache management</a></h2>
<ul>
<li>We can view memory as cache: <em>main memory holds some subset of all the pages in the system</em></li>
<li>Our goal: Picking a replacement policy for this cache to minimize the number of cache misses (minimize number of times we fetch pages from disk)</li>
<li>A nice metric to measure the cache misses and hits is the average memory access time (AMAT) for a program: 
$$
AMAT = T_{M} + (M_{Miss} \cdot T_D)
$$</li>
<li>\(T_M\) cost of accessing memory</li>
<li>\(T_{D}\) cost of accessing disk</li>
<li>\(P_{Miss}\) probability of a cache miss</li>
<li>We always pay the cost of accessing the data in memory</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>We have: </p>
<ul>
<li>4KB address space</li>
<li>256-byte pages</li>
<li>Virtual address has two components, a 4-bits VPN (Used to reference the page frame number on a page table) and an 8 bits offset (Used to calculate the offset from a given page address)</li>
<li>Process can access a total of 16 virtual pages</li>
</ul>
<p>Now assume we have the following address <code>0x000</code>, <code>0x100</code>, <code>0x200</code>, <code>0x300</code>, <code>0x400</code>, <code>0x500</code>, <code>0x600</code>, <code>0x700</code>, <code>0x800</code> and <code>0x900</code> where each of these addresses reference the beginning of a page (the first element of a page)
All pages referenced on the previous address are on memory except for page number 3 (<code>0x300</code>). Hence when trying to access each of these addresses we will encounter the following behavior:</p>
<pre><code>hit, hit, hit, miss, hit, hit, hit, hit, hit, hit
</code></pre>
<p>Our hit rate would be 90%, miss rate 10%, hence \(P_{miss} = 0.1\). To calculate AMAT, we need to know the cost of accessing memory and the cost of accessing disk, let's assume that the cost of accessing to memory (\(T_M\)) is around 100 nano seconds and the cost to access disk (\(T_{D}\)) is around 10 miliseconds, we have the following AMAT :
$$
AMAT = T_{M} + (M_{Miss} \cdot T_{D}) = 100ns + 0.1 \cdot 10ms
$$
Which is
$$
= 1,0001 ms
$$</p>
<p>As you can see the cost of disk is so high compared to the cost of reading to memory that we clearly need to avoid as many misses as possible or we will run slowly at the rate of the disk. </p>
<h2 id="optimal-replacement-policy"><a class="header" href="#optimal-replacement-policy">Optimal Replacement Policy</a></h2>
<ul>
<li>The optimal  replacement policy is a simple policy that replace the page that will be accessed furthest in the future, resulting in the fewest possible cache misses. (Easy to say, really hard to implement)</li>
<li>If we need to throw a page, why not just throw the page that we will need the furthest from now</li>
</ul>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>We access the following virtual pages: 0,1,2,0,1,3,,3,1,2,1 </p>
<center><img src="./images/access_example.png"></center>
<p>As expected we start with 3 misses, we load the pages to memory, then when miss when accessing 3, here we look to the future to check which page we will be accessing last, we see that 0 is acceded intermediately after and that 1 is also accessed a little after that, then we see that the last one is 2, hence we evict 2. After this, we we access 2 (the last miss on the table) we see that both 3 and 0 are valid eviction candidates so we kick either one. </p>
<ul>
<li>Hit rate: 
[HitRate = \frac{Hits}{Hits + Misses} = \frac{6}{6+5} = 54.5% ]</li>
<li>Hit rate <em>modulo</em> (Ignore the first miss for a given page): 
[HitRateMod = \frac{Hits}{Hits + Misses} = \frac{6}{6+1} = 85.7% ]</li>
</ul>
<p>This policy will only be useful when comparing other alternatives to see how far are we from the &quot;perfect&quot; policy</p>
<h2 id="simple-policy-fifo"><a class="header" href="#simple-policy-fifo">Simple policy: FIFO</a></h2>
<ul>
<li>Pages are placed in a queue when they enter the system</li>
<li>When a replacement occurs: The page on the tail of the queue is evicted</li>
</ul>
<p>Let's examine the first example (on Optimal Replacement Policy): </p>
<center><img src="./images/FifoCacheExample.png"></center>
<p>We again begin with 3 misses, the we encounter 2 hits and a miss on access to page 3, since our first in was 0, then this page is evicted. We get a miss on 0 right after that, so we evict 1 because it was the first one to get into the list. Then again we get a miss with 1 and 2 and evict the corresponding pages. </p>
<ul>
<li>Hit rate: 
[HitRate = \frac{Hit} {Hit + Miss} = \frac{4}{4 + 7} = 36.4% ]</li>
<li>Hit rate <em>modulo</em>
[HitRateMod = \frac{Hit}{Hit + Miss} = \frac{4}{4 + 3} = 57.1% ]
We see a much worse performance, because FIFO can't determine the importance of blocks; even though 0 had been accessed a number of times, FIFO still kicks it out.</li>
</ul>
<h2 id="simply-policy-random"><a class="header" href="#simply-policy-random">Simply Policy: Random</a></h2>
<ul>
<li>It simply picks a random page to replace under memory pressure.</li>
<li>It is simple to implement</li>
<li>It isn't too intelligent in picking which blocks to evict</li>
</ul>
<p>On our example above, after running the random policy 1000 times we see the following results:</p>
<center><img src="./images/random_plot.png"></center>
<p>We see that about 40% of the time, Random is as good as optimal achieving 6 hits no the example trace. Sometimes it does much worse tho, achieving 2 or less hits. How random achieves is purely luck.</p>
<h2 id="using-history-lru"><a class="header" href="#using-history-lru">Using History: LRU</a></h2>
<p>We need a smarter policy, FIFO and Random might kick important pages that will be accessed right after they are evicted. </p>
<ul>
<li>We can use <em>history</em> as a guide, if a program has acceded a page in the near past, it is likely to access it again in the near future. </li>
<li>Frequency can also be used: If a page has been accessed many times, perhaps it should not be evicted</li>
<li>Recency of access: A The more recently a page has been accessed, perhaps the more like it will be accessed again 
All this policies are based on the principle of locality
<strong>Principle of locality:</strong> An observation about programs and their behavior, programs tend to access certain code sequences and data structures quite frequently, we should thus try to use history ot figure out which pages are important and keep those pages in memory when it comes to eviction time </li>
</ul>
<p><strong>LRU: Least-Frequently-Used</strong> policy replaces the least-frequently-used page when an eviction must take place. 
<strong>LRU: Least-Recently-Used</strong> policy replaces the least-recently-used page when an eviction must take place. </p>
<center><img src="./images/lru_history.png"></center>
<p>(It's like a FIFO but based on time)
When we encounter a miss on 3, we see which one was the least recently used, in this case is 2 so this is evicted, next we get a miss on 2, and we see that 0 is the least recently used so we evict that. </p>
<h2 id="workload-examples"><a class="header" href="#workload-examples">Workload examples</a></h2>
<h3 id="1-no-locality"><a class="header" href="#1-no-locality">1. No locality</a></h3>
<p>In our first example, our workload has no locality, meaning that each reference is to a random page, within the set of accessed pages.</p>
<ul>
<li>The workloads accesses 100 unique pages over time, choosing the next at random</li>
<li>Overall, 10.000 pages are accessed</li>
</ul>
<center><img src="./images/no_locality.png"></center>
<p>As we can see, LRU, FIFO and Random behave the same when dealing with workflow with no locality
Conclusions from this plot: </p>
<ol>
<li>When there's no locality, it doesn't matter  which realistic policy we choose</li>
<li>When the cache is large enough to fit the entire workload, it also doesn't matter which policy to use. </li>
<li>Optimal (OPT) performs noticeable better than the realistic policies because it can &quot;peek&quot; to the future</li>
</ol>
<h3 id="2-the-80-20-workload"><a class="header" href="#2-the-80-20-workload">2. The 80-20 workload</a></h3>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_14.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="chapter_17.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_14.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="chapter_17.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
