<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Paging - Smaller Tables - Operating Systems: Book Summary</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> The Process</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Process API</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Mechanism - Limited Direct Execution</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Scheduling</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Multi-Level Feedback Queue</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> Proportional Share</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> Address Spaces</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> Mechanism - Address Translation</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">9.</strong> Segmentation</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> Free-Space Management</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> Paging - Introduction</a></li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> Paging - Faster Translation</a></li><li class="chapter-item expanded "><a href="chapter_13.html" class="active"><strong aria-hidden="true">13.</strong> Paging - Smaller Tables</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> Beyond Physical Memory - Mechanism</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">15.</strong> Physical Memory - Policies</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">16.</strong> Concurrency - An Introduction</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">17.</strong> Thread API</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">18.</strong> Locks</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">19.</strong> Lock-Based Concurrent Data Structures</a></li><li class="chapter-item expanded "><a href="chapter_21.html"><strong aria-hidden="true">20.</strong> Condition Variables</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Operating Systems: Book Summary</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="13-paging---smaller-tables"><a class="header" href="#13-paging---smaller-tables">13. Paging - Smaller Tables</a></h1>
<p>Assume we have the following system: </p>
<ul>
<li>32-bit address space (2\({^{32}}\) bytes)</li>
<li>4KB (2\({^{12}}\) bytes) pages</li>
<li>4-byte page-table entry
We then have roughly \(\frac{2^{32}}{2^{12}}\) virtual pages, that's \(1.048.576\), and considering that each page table entry is 4-bytes, we have \(1.048.576 * 4\)  bytes of memory used for the page table only, that is about 4MB in size. We usually have one page table for every process, that is a lot of memory usage for the page table only. How can we decrease this memory usage? </li>
</ul>
<h2 id="simple-solution-bigger-pages"><a class="header" href="#simple-solution-bigger-pages">Simple solution: Bigger pages</a></h2>
<p>If we increase our page table by 4 (that is from 4KB to 16KB), we then decrease or page table memory usage for a process from 4MB to 1MB. The reduction exactly mirrors the factor that we increase our page size. 
The main problems with this solutions is internal fragmentation, we are allocating too much memory for process that might not use all. </p>
<h2 id="hybrid-approach-paging-and-segments"><a class="header" href="#hybrid-approach-paging-and-segments">Hybrid approach: Paging and segments</a></h2>
<p>We combine paging and segmentation in order to reduce the memory overhead of pager tables. We can see why this might work by examining a typical linear page table in more detail: 
Assume we have: </p>
<ul>
<li>An address space with used portions of the heap and stack are small</li>
<li>A tiny 16KB address space with 1KB pages</li>
</ul>
<center><img src="./images/segment_example.png"></center>
<p>Here we have a virtual address space with a code, a heap and a stack segment. However we are only using 1 page on each segment. Page 0 (Code) maps to physical frame 10, Page 4 maps to 23, Page 14 maps to 4 and 15 maps to 28. Most of the pages on our address space are unused, this is a waste of space in our page table, because it stills has to storage 16 entries. </p>
<p><strong>Our hybrid approach:</strong> Instead of having a single page table for our entire virtual address space, we have a page table for each segment (1 table for code, 1 table for heap and 1 table for stack).</p>
<p>What each register will mean on our segment approach: </p>
<ul>
<li><strong>base</strong> register: Holds the physical address of the page table of that segment</li>
<li><strong>bound</strong> register: Used to indicate the end of the page table</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Assume: </p>
<ul>
<li>32-bits virtual address space </li>
<li>4KB pages</li>
<li>Address space split into four segments</li>
<li>We'll only use three segments for this example, code, heap and stack.</li>
<li>To determine a segment an address refers to, we'll use the top two bits of the address space: 
<ul>
<li><code>00</code> is the unused segment </li>
<li><code>01</code> for code</li>
<li><code>10</code> for the heap</li>
<li><code>11</code> for the stack</li>
</ul>
</li>
<li>Our virtual address looks like this:</li>
</ul>
<center><img src="./images/virtual_add.png"></center>
<ul>
<li>The base register for each segment contains the physical address of a linear page table for that segment</li>
<li>Each process has now 3 page tables</li>
<li>On context switch, this registers are changed</li>
</ul>
<p>Main differences with this hybrid approach and the first one: </p>
<ul>
<li>The segment page table will only have the entries that are allocated. Unallocated pages between the stack and the heap no long take up space in a page table </li>
</ul>
<p>Problems: </p>
<ul>
<li>If we have a large but sparsely used heap, for example, we can still end up with a lot of page table waste</li>
<li>This solutions causes external fragmentation, page tables now can be of arbitrary size, thus finding free space for them in memory is more complicated. </li>
</ul>
<h2 id="multi-level-page-tables"><a class="header" href="#multi-level-page-tables">Multi-Level page tables</a></h2>
<p><em>It turns the linear page table into something like a tree.</em>
The basic idea behind a multi-level page table is simple: </p>
<ol>
<li>Chop up the page table into page-sized units</li>
<li>If an entire page of page-table entries is invalid, don't allocate that page of the page table at all</li>
<li>To track whether a page of the page table is valid, use a new structure, called the page directory (note: Each process has his own page directory structure)</li>
<li>The page directory, can be used to tell you where a page of the page table is, or to tell if the entire page of the page table contains no valid pages</li>
</ol>
<center><img src="./images/multi-level-pt.png"></center>
<p>On this image we can see: </p>
<ul>
<li><strong>PDBR:</strong> Page directory base registers,  this holds the physical address where the page directory is.</li>
<li>The page directory: Maps to a page that contains a page table (this can be initialized or not initialized )</li>
<li>Just two page-table are mark as valid (1), hence only this 2 are initialized in memory</li>
</ul>
<p>The page directory: </p>
<ul>
<li>It contains one entry pert page of the page table</li>
<li>It consist of a number of page directory entries (PDE) which has a <em>valid</em> bit and a page frame number (to what frame number that page table maps to)</li>
<li>If the PDE is valid, it means that at least one element on the page table is valid </li>
</ul>
<h3 id="advantages-of-multi-level-pages"><a class="header" href="#advantages-of-multi-level-pages">Advantages of multi-level pages</a></h3>
<ul>
<li>Only allocates page-tables space in proportion to the amount of address space you are using</li>
<li>If carefully constructed, each portion of the page table first neatly within a page, making it easier to manage memory </li>
</ul>
<h3 id="cost-of-multi-level-pages"><a class="header" href="#cost-of-multi-level-pages">Cost of multi-level pages</a></h3>
<p>On TLB miss, two loads from memory will be required to get the right translation information from the page table, one for the page directory and one for the PTE itself. </p>
<h2 id="example-multi-level-page-tables"><a class="header" href="#example-multi-level-page-tables">Example multi-level page tables</a></h2>
<p>We have the following system: </p>
<ul>
<li>Small address space of size 16KB</li>
<li>64-byte pages</li>
<li>14-bit virtual address space</li>
<li>8 bits for the VPN</li>
<li>6 bits for the offset</li>
<li>A linear page table would have 2\({^8}\) entries</li>
</ul>
<p>For this example we have virtual page 0 and 1 for code, virtual page 4 and 5 for the heap, virtual pages 254 and 255 for the stack. The rest is <strong>unused</strong> </p>
<center><img src="./images/address_space_22.png"></center>
<h3 id="building-a-two-level-page-table"><a class="header" href="#building-a-two-level-page-table">Building a two-level page table</a></h3>
<ul>
<li>We start with our full linear page table, and break it up into page-sized units (each page is 64 bytes in size). </li>
<li>Full table has 256 entries</li>
<li>Assume each PTE is 4 bytes, hence our entire table is using 256 * 4 bytes = 1024 bytes</li>
<li>Because our page size is 64, we are using 16 pages for our page table</li>
</ul>
<p>Todo: How to take a VPN and use it to index first into the page directory and then into the page of the page table. </p>
<p>First, to index the page directory: We can do this by using 4 bits of our VPN bits, we need 4 bits because we have 16 possible pages to reference, 2\({^4}\) = 16.</p>
<center><img src="./images/vpn_page_dir.png"></center>
From here we can use the page directory index to get our page directory entry (PDE) with a simple calculation: `PDEAddr = PageDirBase + (PDIndex * sizeof(PDE)` 
- This is our page directory entry is marked invalid, we know that the access is invalid and raise and exception. 
- If the PDE is valid, we fetch the page table entry (PTE) from the page of the page table pointed to by this page directory entry, to find the PTE we use the remaining bits in our VPN
<p><img src="pte_index.png" alt="PTE index" /></p>
<p>This can be then used to index into the page table itself, here <code>PDE.PFN</code> is the page frame number of the page (or the address of the first element on the PDE) which is the indexed to the page table index we want: </p>
<pre><code>PTEAddr = (PDE.PFN &lt;&lt; SHIFT) + (PTIndex * sizeof(PTE))
</code></pre>
<h3 id="more-than-two-levels"><a class="header" href="#more-than-two-levels">More than two levels</a></h3>
<p>We have the following situation: </p>
<ul>
<li>30 bit virtual address space (the max address number I can represent is 30 bits)</li>
<li>A 512 bytes page (max number I can represent is 9 bits)</li>
<li>Hence our virtual space uses 21 bits to reference the page and 9 bits to reference the exact memory address inside that page </li>
</ul>
<p>Our goal when constructing a multi-level page table: Make each piece of the page table fit within a single page (meaning our page directory must fit inside a single page). </p>
<h4 id="how-to-determine-how-many-levels-are-needed-on-a-multi-level-table"><a class="header" href="#how-to-determine-how-many-levels-are-needed-on-a-multi-level-table">How to determine how many levels are needed on a multi-level table?</a></h4>
<ul>
<li>First we start by deterring how many page-table entries fit within a page: On our example, a page has a size of 512 bytes, and a PTE has a size of 4 bytes, which means a page can fit up to 128 PTEs. This means that we need 7 bits to represent the 128 values a page-table entry may have. </li>
</ul>
<center><img src="./images/pteentry.png"></center>
<ul>
<li>As we can see, we have 7 bits for the page table index (to index PTE) and 14 bits for the page directory entries </li>
<li>If we have 14 bits for the page directory index, that would mean 2\({^{14}}\) entries on our page directory, which spans not one page but 128, and thus our goal of making the directory entry fit on one page fails. 
To fix this, we create a further level of the tree, by spiting the page directory itself into multiple pages, and then adding another page directory on top of that. A memory reference number would look like this: </li>
</ul>
<center><img src="./images/final-mutlilevel.png"></center>
<center><i>Note: This "more than two levels" part is incomplete</i></center>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_12.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="chapter_14.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_12.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="chapter_14.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
