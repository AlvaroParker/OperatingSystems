<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Segmentation - Operating Systems: Book Summary</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> The Process</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Process API</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Mechanism - Limited Direct Execution</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Scheduling</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Multi-Level Feedback Queue</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> Proportional Share</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> Address Spaces</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> Mechanism - Address Translation</a></li><li class="chapter-item expanded "><a href="chapter_9.html" class="active"><strong aria-hidden="true">9.</strong> Segmentation</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> Free-Space Management</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> Paging - Introduction</a></li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> Paging - Faster Translation</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">13.</strong> Paging - Smaller Tables</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> Beyond Physical Memory - Mechanism</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">15.</strong> Physical Memory - Policies</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">16.</strong> Concurrency - An Introduction</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">17.</strong> Thread API</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">18.</strong> Locks</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">19.</strong> Lock-Based Concurrent Data Structures</a></li><li class="chapter-item expanded "><a href="chapter_21.html"><strong aria-hidden="true">20.</strong> Condition Variables</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Operating Systems: Book Summary</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="9-segmentation"><a class="header" href="#9-segmentation">9. Segmentation</a></h1>
<p><em>Note: MMU = Memory management unit</em>
Problem with base-and-bound seen at <em>8</em> is that there is a big chunk of &quot;free&quot; space right in the middle, between the stack and the heap.
The simple approach of using base and bound register pair to virtualize memory is wasteful and it doesn't help us either when the memory of the program is bigger than the address space. </p>
<h2 id="crux-how-to-support-a-large-address-space"><a class="header" href="#crux-how-to-support-a-large-address-space">Crux: How to support a large address space</a></h2>
<p>How do we support a large address space with a lot of free space between the stack and the heap?</p>
<h2 id="segmentation-generalized-basebounds"><a class="header" href="#segmentation-generalized-basebounds">Segmentation: Generalized Base/Bounds</a></h2>
<p>Instead of having a base and bounds per address space, we have base and bound per logical segment of the address space. </p>
<ul>
<li>Segment: Contiguous portion of the address space of a particular length. In our case, we have code, stack and heap. </li>
<li>Segmentation allows us to place each one of this segments in different places in physical memory</li>
</ul>
<center><img src="./images/SegmentSpace.png"></center>
<p>In this figure we can see the different segments (Stack, Code and Heap) of a process. Each one is located independently of one another and only used memory is allocated space in physical memory, thus large address spaces with large amount of unused address space can be accommodated. </p>
<ul>
<li>The hardware structure in our MMU is a set of 3 base and bound register pairs:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Base</th><th>Size</th></tr></thead><tbody>
<tr><td>Code</td><td>32K</td><td>2K</td></tr>
<tr><td>Heap</td><td>34K</td><td>3K</td></tr>
<tr><td>Stack</td><td>28K</td><td>2K</td></tr>
</tbody></table>
</div>
<h3 id="example-translation"><a class="header" href="#example-translation">Example translation</a></h3>
<center><img src="./images/SegmentAP.png"></center>
<p>If we have a program with the address space of the figure above and is placed on physical memory as the first figure illustrated. 
*Note: Offset is defined as the &quot;distance&quot; between the virtual address we are referencing and the start of the segment</p>
<ul>
<li>Reference virtual address 100 (Code): The hardware adds the <code>base</code> value (see first table) to the <em>offset</em> into this segment (100 in this case). Physical address: 100 + 32KB = 32868</li>
<li>Reference to virtual address 4200 (heap): The offset of this segment is 4200 minus 4KB because the heap starts at address 4K. Then we add the base value (34K) to the calculated <em>offset</em> (104) to get 34920</li>
<li>In general the operation is (For positive growing segments): </li>
</ul>
<pre><code>offset = (virtual mem value - segment start value virtual mem)
physical address = offset + segment base
</code></pre>
<ul>
<li>For the heap: 
<ul>
<li>Segment start value at virtual memory = 4KB</li>
<li>Virtual mem value (the address we want to reference) = 4200</li>
<li>Base heap value = 34K</li>
</ul>
<ul>
<li>Physical address = (4200 - 4096) + 34816 = 34920</li>
</ul>
</li>
</ul>
<h2 id="which-segment-are-we-referring"><a class="header" href="#which-segment-are-we-referring">Which segment are we referring</a></h2>
<p>Explicit approach chop up the address space in segments based on the top few bits of the virtual address. If our example we have 3 segments so we need 2 bits to represent each one, hence we will use the top 2 bits of our 14-bit virtual address to select the segment. </p>
<center><img src="./images/SegmentExplicit.png"></center>
<ul>
<li>
<p>If the top bits are 00, the virtual address is in the code segment, if it's 01 then it's in the heap segment.</p>
</li>
<li>
<p>If we wanted to refer to virtual address 4200, which can be seen in binary form as: </p>
</li>
</ul>
<center><img src="./images/addressExample.png"></center>
<ul>
<li>
<p>We see that our segment is 01 (Heap) on our offset value in decimal is 104. We add the base register to the offset and we get the physical address</p>
</li>
<li>
<p>If base and bounds where arrays, the hardware would be doing something like this to obtain the desired physical address </p>
</li>
</ul>
<pre><code class="language-C">// Get top 2 bits of 14-bit VA
Segment = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SEG_SHIFT
/// Now get the offset
Offset = VirtualAddress &amp; OFFSET_MASK
if (Offset &gt;= Bounds[Segment])
	RaiseException(PROTECTION_FAULT)
else
	PhysAddr = Base[Segment] + Offset
	Register = AccessMemory(PhysAddr)
</code></pre>
<h4 id="issues"><a class="header" href="#issues">Issues:</a></h4>
<ul>
<li>When we use the top two bits and only have 3 segments, one segment of the address space goes unused. </li>
<li>It limits use of the virtual address space, each segment is limited to a maximum size (4KB in this case because that's the max number that can be represented using 12 bits = 14 bits - 2 top bits). If we want a bigger segment we are out of luck. </li>
</ul>
<h4 id="possible-fixes"><a class="header" href="#possible-fixes">Possible fixes:</a></h4>
<ul>
<li>Implicit approach: The hardware determines the segment by noticing how the address was formed. </li>
</ul>
<h2 id="the-stack"><a class="header" href="#the-stack">The stack</a></h2>
<p>In our first diagram, we can see that our stack is located at physical memory 28KB but with one critical difference: <em>it grows backwards</em></p>
<ul>
<li>In physical memory it starts at 28KB and grows back to 26KB</li>
</ul>
<ul>
<li>Corresponding to virtual address 16KB to 14KB</li>
</ul>
<p>To keep track of the direction a segment grows we need help from the hardware (register set to 0 indicates negatives grow and 1 indicates positive grow)</p>
<div class="table-wrapper"><table><thead><tr><th>Segment</th><th>Base</th><th>Size</th><th>Grows Positive?</th></tr></thead><tbody>
<tr><td>Code</td><td>32K</td><td>2K</td><td>1</td></tr>
<tr><td>Heap</td><td>34K</td><td>3K</td><td>1</td></tr>
<tr><td>Stack</td><td>28K</td><td>2K</td><td>0</td></tr>
</tbody></table>
</div>
<h3 id="stack-address-translation"><a class="header" href="#stack-address-translation">Stack address translation</a></h3>
<p>In this example we want to access virtual address 15KgB</p>
<ul>
<li>The stack segment starts at 16KB, hence the offset is 15KB - 16KB = -1KB</li>
<li>The base of the stack is at physical address 28KB, hence the address we want to access is at -1KB + 28KB = 27KB </li>
<li>Bound is check by checking that the absolute value of the negative offset (1KB in this case) is less than or equal to the segment's current size (2KB in this case)</li>
</ul>
<h2 id="support-for-sharing"><a class="header" href="#support-for-sharing">Support for sharing</a></h2>
<p>We can also add support for sharing segments of memory between address spaces.</p>
<ul>
<li>We need extra hardware support in the form of protection bits. </li>
<li>Protection bits: Adds a few bits per segment indicating if a segment can be read, write and/or executable</li>
<li>If you set a code to read only, you can share it across multiple processes, without worry of harming isolation. 
With this, we now have the following segment registers values:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Segment (Top bit)</th><th>Base</th><th>Size</th><th>Grows Positive?</th><th>Protection</th></tr></thead><tbody>
<tr><td>Code (<code>00</code>)</td><td>32KB</td><td>2KB</td><td>1</td><td>Read-execute</td></tr>
<tr><td>Heap (<code>01</code>)</td><td>34KB</td><td>3KB</td><td>1</td><td>Read-Write</td></tr>
<tr><td>Stack (<code>11</code>)</td><td>28KB</td><td>2KB</td><td>0</td><td>Read-Write</td></tr>
</tbody></table>
</div>
<ul>
<li>With this, the hardware algorithm seen before now has to check that the segment where that a virtual memory is referencing, has the proper permissions (read, write or execute) </li>
</ul>
<h2 id="fine-grained-vs-coarse-grained-segmentation"><a class="header" href="#fine-grained-vs-coarse-grained-segmentation">Fine-grained vs. Coarse-grained Segmentation</a></h2>
<ul>
<li>Segmentation with a few segments (i.e just Code, Heap and Stack): coarse-grained</li>
<li>Coarse grained segmentation: Chops up the address space into relatively large coarse chunks</li>
<li>In contrast: Large number of smaller segments is referred to as fine-grained segmentation.</li>
<li>To support fine-grained segmentation we need even further hardware support with a segment table of some kind stored in memory.</li>
</ul>
<h2 id="os-support"><a class="header" href="#os-support">OS Support</a></h2>
<h4 id="segmentation-raises-a-number-of-new-issues-for-the-operating-system"><a class="header" href="#segmentation-raises-a-number-of-new-issues-for-the-operating-system">Segmentation raises a number of new issues for the operating system:</a></h4>
<ol>
<li>What should the OS do on a context switch? Segment registers must be saved some place in memory and restored. </li>
<li>OS interaction when segments grow (or shrink). If a program calls <code>malloc()</code> to allocate space on the heap, but there isn't enough available memory to allocate this, the heap segment must grow, in this case, the memory-allocation library will perform a system call to grow the heap (i.e. <code>sbrk()</code> on Linux), the OS would then grow the segment size and updating the segment size registers to the new size, and informing the library of success (or failure if there isn't enough space or an arbitrary limit has been reached.)</li>
<li>Managing free space in physical memory. When a new process is created we have to allocate the address space in physical memory, however, the size of each segment is not constant now. This arises a problem, physical memory quickly becomes full of little holes of free space, making it difficult to allocate new segments (this problem is known as <strong>external fragmentation</strong> )</li>
</ol>
<h4 id="possible-solutions"><a class="header" href="#possible-solutions">Possible solutions:</a></h4>
<ol>
<li>Compact physical memory: By rearranging the existing segments, we compact the physical memory. If a process segment doesn't have enough space in his current position at the physical memory, move it entirely to new part of the physical memory, updating the segment registers. 
<ul>
<li>This is expensive (CPU and Memory wise) </li>
<li>Uses a fair amount of processor time</li>
</ul>
</li>
<li>Use a free-list management algorithm that tries to keep large extents of memory available for allocation (There are hundred of this kind of algorithms)</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_8.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="chapter_10.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_8.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="chapter_10.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
