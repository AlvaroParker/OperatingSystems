# 19. Locks 
We want to execute a series of instruction atomically, due to the presence of interrupts, we couldn't. To solve this we introduce lock, which we put around critical section and ensure this sections is executed as a single atomic instruction. 

## The basic idea
We have a critical section that looks like this:
```C
balance = balance + 1;
```
To use a lock, we add some code around the critical section like this:
```C
lock_t mutex; // Some globally-allocated lock `mutex`
...
lock(&mutex);
balance = balance + 1;
unlock(&mutex);
```
- Lock is just a variable 
- It stores the state of the lock at any given time
- It's either available or acquired
- We can store more data in the lock such as the current thread that's holding it, or a list of some kind for ordering lock acquisition

The general flow of locks are describe here: 
- Calling `lock()` tries to acquire the lock
- If no other thread holds the lock, the thread will acquire the lock and enter the critical section
- If another thread tries to acquire the lock, the thread will not return while the lock is held by another thread. This way, other threads are prevented from entering the critical section. .
- Once the owner of the lock calls `unlock()`, the lock is now available again to other threads. 
- If there are no other threads waiting for the lock, the state of the lock is set to free. 
- If there are waiting threads, one of them will notice and will acquire the lock and enter critical section.

With locks we make sure than only a single thread can access a critical section of code. 

## Pthread locks 
The name the POSIX library uses for a lock is `mutex` as it is used to provide mutual exclusion between threads. When you see the following threads code, assume that's doing the same thing as above: 
```C
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

Pthread_mutex_lock(&lock); // wrapper; exits on failure
balance = balance + 1;
Pthread_mutex_unlock(&lock);
```
Passing a variable to lock and unlock helps us avoid locking all threads with one lock (coarse-grained locking strategy) and doing a more specific thread lock (a more fine-grained approach) 

## Evaluating Locks 
To build locks we must defined some evaluation criteria:
- Does the lock provides mutual exclusion. Does the lock work, preventing multiple threads from accessing a critical section.
- Fairness. Does each thread contending the lock gets a fair shot at acquiring it once its free. 
- Performance. The time overheads added by using the lock. 
	- When a single thread grabs and releases the lock, what's the overhead of doing so
	- Is there a performance overhead when multiple threads are contending for a lock. 
	- How does the lock performs when there are multiple CPU's involved and threads on each contending lock. 

## Controlling interrupts
One solution to implement mutex was to disable interrupts for critical sections. The could would look like this: 
```C
void lock() {
	DisableInterrupts();
} 
void unlock() {
	EnableInterrupts();
}
```
Assuming that we are running on a single processor system, by turning off interrupts before entering a critical section, we ensure that the code inside this section won't be interrupted 

#### Benefits
- Simplicity: Easy to implement and to grasp. 
#### Negatives
- This allows any calling thread to perform a privileged operation, we must trust that this is not abused. 
- Greedy program calls lock and never `unlock` hence taking over the entire CPU
- Buggy or malicious program could call `lock` and enter a loop, OS never regains control and we must restart the entire system
- Does not work on multiple CPUs systems, if a thread disables interrupts, a thread running on a different CPU can still access critical section. 
- Running off interrupts for extended period of time can lead to interrupts becoming lost. 
- Inefficient: Code that mask and unmask interrupts are CPU inefficient. 

This negatives **might** be acceptable when running OS level programs, since the OS trust it self. 

## Just Using Loads/Stores
Block using single flag variable (`flag`) to indicate whether some thread has possession of a lock. 
- The first thread that enters the critical section calls `lock()` which check if the `flag` is set to 1 (in this case, is not), and then sets the flag to 1 to indicate that the thread now holds the lock. 
- When the thread finishes with the critical section, it calls `unlock()` which clears the flag
- If another thread calls `lock()` while the lock is held, it will find that the flag is set to 1 so it will simply *spin-wait* in a while loop for that thread to call `unlock` and clear the flag
- Once that first thread does clear the flag, the waiting thread fall out of the while loop, sets the flag to 1 for itself and proceeds into the critical section .

```C
typedef struct __lock_t { int flag; } lock_t;

void init(lock_t *mutex) {
	// 0 -> lock is available, 1 -> held
	mutex->flag = 0;
}
void lock(lock_t *mutex) {
	while (mutex->flag == 1) // TEST the flag
		;
	mutex->flag = 1; // now SET it!
}
void unlock(lock_t *mutex) {
	mutex->flag = 0;
}
```

This implementation has two errors.
1. The first one is that we can easily produce a case where both threads set the flag to 1, and both threads are thus able to enter critical section. 
2. The second being a performance error, the `lock` routine does a **spin-waiting**, which wastes time waiting for another thread to release a lock but at the same time running on the CPU. On a single CPU system, how can a thread be waiting for a lock while using the CPU if the other threads needs to use it to free the lock? Doesn't makes sense. 