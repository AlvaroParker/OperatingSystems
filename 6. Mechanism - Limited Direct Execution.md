*CPU virtualization: Run one process for a little while, then another one, and so forth. By time sharing the CPU, virtualization is achieved.*

-> Challenges in building this virtualization: 
1. Performance: How to implement without adding excessive overhead to the system?
2. Control: How to run processes efficiently while retaining control over the CPU?

## Crux: How to efficiently virtualize the CPU with control?

## Basic technique: Limited direct execution
- "Direct Execution" part: Run the program directly on the CPU
	- OS wishes to start a program running: 
		1. OS creates a process entry for it in a process list.
		2. Allocated some memory for it.
		3. Loads the program code into memory (from disk)
		4. Locates its entry point, jumps to it and starts running the users' code
	  * Problems:
		  1. How can the OS make sure the program doesn't do anything that we don't want it to do, while still running efficiently.
		  2. How to do the context switch (stop the program it from running and switch to another process)

## Problem #1: Restricted operations 
**Crux: A process must be able to perform I/O and some other restricted operations, but without giving the process complete control over the system. How can the OS and hardware work together to do so?**

- Approach: Introduce a new processor mode: *user mode* 
	- Code that runs in user mode is restricted in what it can do (i.e it can't issue I/O requests)
- Contrast to *user mode*: *kernel mode* 
	- Code that runs can do what it likes.

How can we perform some kind of privileged operation (such as reading from disk)?
-> Solution: System Calls
-> 